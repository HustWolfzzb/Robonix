import os
import importlib
import functools
import ast
from mcp.server.fastmcp import FastMCP
import yaml
import sys
if os.path.abspath(os.path.dirname(__file__)) not in sys.path:
    sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from constant import BASE_SKILL_PATH, INIT_FILE, BASE_PATH
mcp = FastMCP("eaios")
# from mcp import tool


if os.path.dirname(BASE_PATH) not in sys.path:
    sys.path.append(os.path.dirname(BASE_PATH))

# 使用模块属性作为全局注册表
if not hasattr(sys, '_eaios_function_registry'):
    # 首次加载时初始化
    sys._eaios_function_registry = {
        'registered_funcs': []
    }

def ensure_init_file():
    os.makedirs(BASE_SKILL_PATH, exist_ok=True)
    if not os.path.exists(INIT_FILE):
        with open(INIT_FILE, "w") as f:
            f.write("# Auto-generated by @eaios.api\n__all__ = []\n")

def update_import_and_all(func_name: str, full_module_path: str):
    ensure_init_file()
    import_line = f"from {full_module_path} import {func_name}"

    with open(INIT_FILE, "r+") as f:
        content = f.read()
        lines = content.splitlines()

        if import_line not in lines:
            lines.append(import_line)

        all_list = []
        found_all = False
        new_lines = []
        for line in lines:
            if line.strip().startswith("__all__"):
                try:
                    parsed = ast.parse(line)
                    assign = parsed.body[0]
                    if isinstance(assign, ast.Assign) and isinstance(assign.value, ast.List):
                        all_list = []
                        for elt in assign.value.elts:
                            if isinstance(elt, ast.Constant):
                                all_list.append(elt.value)
                            elif hasattr(elt, 's'):  # for compatibility
                                all_list.append(elt.s)
                        if func_name not in all_list:
                            all_list.append(func_name)
                    found_all = True
                    new_line = f"__all__ = {sorted_repr(all_list)}"
                    new_lines.append(new_line)
                except Exception:
                    new_lines.append(line)
            else:
                new_lines.append(line)

        if not found_all:
            new_lines.insert(1, f"__all__ = {sorted_repr([func_name])}")

        f.seek(0)
        f.write("\n".join(new_lines) + "\n")
        f.truncate()

def sorted_repr(str_list):
    return "[" + ", ".join(f'"{s}"' for s in sorted(set(str_list))) + "]"

class FunctionRegistry:
    @staticmethod
    def add_function(func_name, module_name):
        sys._eaios_function_registry['registered_funcs'].append((func_name, module_name))
    
    @staticmethod
    def get_functions():
        return sys._eaios_function_registry['registered_funcs'].copy()
    
    @staticmethod
    def gen_lens():
        return len(sys._eaios_function_registry['registered_funcs'])


class eaios:
    @staticmethod
    def api(func):
        func = mcp.tool()(func)

        full_mod = func.__module__
        print("full mod",full_mod, "function name", func.__name__)
        # print(f"[DEBUG] API 开始: _registered_funcs = {_registered_funcs}, ID={id(_registered_funcs)}")
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)
        # print(f"[DEBUG] API 添加后: _registered_funcs = {_registered_funcs}, ID={id(_registered_funcs)}")
        return func

    @staticmethod
    def finalize():
        registry = FunctionRegistry()
        funcs = registry.get_functions()
        print("funcs",funcs)
        for func_name, full_mod in funcs:
            update_import_and_all(func_name, full_mod)

    @staticmethod
    def scan_dir(base_package: str, base_dir: str):
        """
        自动递归导入 base_dir 下所有api（api.py 文件），触发注册，再 finalize。
        - base_package: 如 'test_api.cap.hello1.api'
        - base_dir: 绝对路径，对应 base_package 的目录
        """
        for root, dirs, files in os.walk(base_dir):
            for file in files:
                if file == "api.py":
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, base_dir)  # e.g., 'x/y/z.py'
                    module_parts = rel_path[:-3].replace(os.sep, ".")  # remove .py
                    module_path = f"{base_package}.{module_parts}"
                    print(module_path)

                    try:
                        importlib.import_module(module_path)
                    except Exception as e:
                        print(f"[eaios] Failed to import {module_path}: {e}")

    @staticmethod
    def caller(func):
        """
        装饰器：从 __init__.py 中动态导入所有 __all__ 中列出的函数
        """

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            skill_module = importlib.import_module("DeepEmbody.skill")  # 必须是模块路径
            for name in getattr(skill_module, "__all__", []):
                func.__globals__[name] = getattr(skill_module, name)
            return func(*args, **kwargs)

        return wrapper
        # @functools.wraps(func)
        # def wrapper(*args, **kwargs):
        #     with open(INIT_FILE, 'r') as f:
        #         for line in f:
        #             if line.startswith('from'):
        #                 parts = line.strip().split()
        #                 if len(parts) == 4 and parts[0] == 'from' and parts[2] == 'import':
        #                     rel_module = parts[1].lstrip('.')
        #                     full_module = f"base_path.skill.{rel_module}"
        #                     func_name = parts[3]
        #                     imported = getattr(importlib.import_module(full_module), func_name)
        #                     func.__globals__[func_name] = imported
        #     return func(*args, **kwargs)
        # return wrapper
def package_init(config_path: str):
    """
    初始化包，扫描 config_path 中的所有模块并注册。
    """
    if os.path.exists(INIT_FILE):
        os.remove(INIT_FILE)
    config_path = os.path.join(BASE_PATH, config_path)
    if not os.path.exists(config_path):
        print(f"[eaios] Error: The configuration file '{config_path}' does not exist.")
        return
    config = {}
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    for base,entrys in config.items():
        if entrys is None:
            continue
        for entry in entrys:
            entry_dir = os.path.join(BASE_PATH, base, entry)
            if not os.path.exists(entry_dir):
                print(f"[eaios] Error: The '{entry_dir}' directory was not found at '{base}'")
                continue
            base_package = f"DeepEmbody.{base}.{entry}"
            eaios.scan_dir(base_package, entry_dir)
    print("before finalize")
    eaios.finalize()
    registry = FunctionRegistry()
    print(f"[eaios] Package initialized with {registry.gen_lens()} functions registered.")

if __name__ == "__main__":
    import yaml, argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", type=str, default="config/include.yaml")
    args = parser.parse_args()
    package_init(args.config)
    registry = FunctionRegistry()
    print(f"[eaios] Finalized with {registry.gen_lens()} functions registered.")