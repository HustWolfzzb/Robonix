import asyncio
import os
import importlib
import functools
import ast
from mcp.server.fastmcp import FastMCP
import yaml
import sys
import inspect
if os.path.abspath(os.path.dirname(__file__)) not in sys.path:
    sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from constant import BASE_SKILL_PATH, BASE_PATH, BASE_BRAIN_PATH, BRAIN_INIT_FILE, SKILL_INIT_FILE
from log import logger
if os.path.dirname(BASE_PATH) not in sys.path:
    sys.path.append(os.path.dirname(BASE_PATH))

# use a global variable to store registered functions
if not hasattr(sys, '_eaios_function_registry'):
    # initialize the registry
    sys._eaios_function_registry = {
        'registered_funcs': []
    }

def ensure_init_file(init_file):
    os.makedirs(os.path.dirname(init_file), exist_ok=True)
    if not os.path.exists(init_file):
        with open(init_file, "w") as f:
            f.write("# Auto-generated by @eaios\n__all__ = []\n")

def update_import_and_all(func_name: str, full_module_path: str, init_file):
    ensure_init_file(init_file)
    import_line = f"from {full_module_path} import {func_name}"

    with open(init_file, "r+") as f:
        content = f.read()
        lines = content.splitlines()

        if import_line not in lines:
            lines.append(import_line)

        all_list = []
        found_all = False
        new_lines = []
        for line in lines:
            if line.strip().startswith("__all__"):
                try:
                    parsed = ast.parse(line)
                    assign = parsed.body[0]
                    if isinstance(assign, ast.Assign) and isinstance(assign.value, ast.List):
                        all_list = []
                        for elt in assign.value.elts:
                            if isinstance(elt, ast.Constant):
                                all_list.append(elt.value)
                            elif hasattr(elt, 's'):  # for compatibility
                                all_list.append(elt.s)
                        if func_name not in all_list:
                            all_list.append(func_name)
                    found_all = True
                    new_line = f"__all__ = {sorted_repr(all_list)}"
                    new_lines.append(new_line)
                except Exception:
                    new_lines.append(line)
            else:
                new_lines.append(line)

        if not found_all:
            new_lines.insert(1, f"__all__ = {sorted_repr([func_name])}")

        f.seek(0)
        f.write("\n".join(new_lines) + "\n")
        f.truncate()

def sorted_repr(str_list):
    return "[" + ", ".join(f'"{s}"' for s in sorted(set(str_list))) + "]"

class FunctionRegistry:
    @staticmethod
    def add_function(func_name, module_name):
        sys._eaios_function_registry['registered_funcs'].append((func_name, module_name))
    
    @staticmethod
    def get_functions():
        return sys._eaios_function_registry['registered_funcs'].copy()
    
    @staticmethod
    def gen_lens():
        return len(sys._eaios_function_registry['registered_funcs'])

# 缓存已导入的技能模块
_skill_module_cache = None

def get_skill_module():
    """获取技能模块（延迟导入+缓存）"""
    global _skill_module_cache
    if _skill_module_cache is None:
        try:
            # 延迟导入技能模块
            _skill_module_cache = importlib.import_module("DeepEmbody.skill")
            logger.info(f"成功导入技能模块: {_skill_module_cache.__file__}")
        except ImportError as e:
            logger.error(f"导入技能模块失败: {e}")
            _skill_module_cache = None
    return _skill_module_cache

def inject_skill_functions(func):
    """将技能函数注入到目标函数的全局作用域"""
    skill_module = get_skill_module()
    if not skill_module:
        logger.warning("无法注入技能函数 - 技能模块未加载")
        return func
    # 获取目标函数的全局作用域
    globals_dict = func.__globals__
    
    # 注入所有公开函数
    for name in getattr(skill_module, "__all__", []):
        try:
            # 只在函数不存在时注入
            if name not in globals_dict:
                globals_dict[name] = getattr(skill_module, name)
                logger.debug(f"注入技能函数: {name}")
        except AttributeError as e:
            logger.warning(f"无法注入函数 {name}: {e}")
    
    return func


class eaios:
    mcp = FastMCP(
        name="eaios",
        host="127.0.0.1",
        port=8001,
        sse_path="/sse",
        message_path="/messages/"
    )
    FUNCTION_REGISTRY = {}
    @staticmethod
    def cap(func):
        print("eaios.__module__ =", eaios.__module__)
        print("eaios class id =", id(eaios))

        full_mod = func.__module__
        print("full mod",full_mod, "function name", func.__name__)
        # print(f"[DEBUG] API 开始: _registered_funcs = {_registered_funcs}, ID={id(_registered_funcs)}")
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)
        # print(f"[DEBUG] API after: _registered_funcs = {_registered_funcs}, ID={id(_registered_funcs)}")
        return func

    @staticmethod
    def plugin(cap,name):
        def decorator(func):
            eaios.FUNCTION_REGISTRY[cap + ":" + name + ":" + func.__name__] = func
            return func
        return decorator

    def get_plugin(cap,name,func_name = None):
        if func_name == None:
            current = inspect.currentframe()
            caller = current.f_back
            func_name = caller.f_code.co_name if caller else None

        plugin_name = cap + ":" + name + ":" + func_name
        # auto raise KeyError
        # if plugin_name not in eaios.FUNCTION_REGISTRY.keys():
        #     raise 
        return eaios.FUNCTION_REGISTRY[plugin_name]

    @staticmethod
    def finalize():
        registry = FunctionRegistry()
        funcs = registry.get_functions()
        print("funcs",funcs)
        for func_name, full_mod in funcs:
            update_import_and_all(func_name, full_mod, SKILL_INIT_FILE)
            if "skill" in full_mod:
                update_import_and_all(func_name, full_mod, BRAIN_INIT_FILE)

    @staticmethod
    def scan_dir(base_package: str, base_dir: str):
        """
        import base_package recursively
        e.g., base_package = "DeepEmbody.capability.plugins"
        """
        for root, dirs, files in os.walk(base_dir):
            if "__pycache__" in root: 
                continue
            if "capability" in root and "plugins" in root:
                for file in files:
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, base_dir)  # e.g., 'x/y/z.py'
                    module_parts = rel_path[:-3].replace(os.sep, ".")  # remove .py
                    module_path = f"{base_package}.{module_parts}"
                    print(module_path)

                    try:
                        importlib.import_module(module_path)
                    except Exception as e:
                        print(f"[eaios] Failed to import {module_path}: {e}")
            else:
                for file in files:
                    if file == "api.py":
                        full_path = os.path.join(root, file)
                        rel_path = os.path.relpath(full_path, base_dir)  # e.g., 'x/y/z.py'
                        module_parts = rel_path[:-3].replace(os.sep, ".")  # remove .py
                        module_path = f"{base_package}.{module_parts}"
                        print("[DEBUG] scan_dir: ",module_path)

                        try:
                            importlib.import_module(module_path)
                        except Exception as e:
                            print(f"[eaios] Failed to import {module_path}: {e}")
    @staticmethod
    def brain(func):
        """
        decorator, from brain's __init__ import all from brain module
        """

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # if os.path.abspath(os.path.dirname(__file__)) not in sys.path:
            #     sys.path.append(os.path.abspath(os.path.dirname(__file__)))
            print("[DEBUG] __file__:", __file__)
            print("[DEBUG] cwd:", os.getcwd())
            print("[DEBUG] sys.path:",sys.path)
            brain_module = importlib.import_module("DeepEmbody.brain")
            print(id(brain_module),brain_module.__file__)
            print(eaios.FUNCTION_REGISTRY)
            for name in getattr(brain_module, "__all__", []):
                func.__globals__[name] = getattr(brain_module, name)
            return func(*args, **kwargs)

        return wrapper
    
    @staticmethod
    def skill(func):
        """
        decorator for skill functions
        This decorator does three things:
        1. register the function in the global registry
        2. import the skill module from DeepEmbody.skill
        3. avoid circular imports by using a wrapper function
        """
        # step1: register the function
        full_mod = func.__module__
        logger.info(f"register: {func.__name__} from {full_mod}")
        
        # step2: update the import and __all__ in skill_init.py
        registry = FunctionRegistry()
        registry.add_function(func.__name__, full_mod)
        
        # step3: inject skill functions into the function's global scope
        @eaios.mcp.tool()  # apply MCP tool decorator
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # aplly skill functions injection only once
            nonlocal func
            if not hasattr(wrapper, '_injected'):
                logger.debug(f"register firstly {func.__name__}, injecting skill functions...")
                func = inject_skill_functions(func)
                wrapper._injected = True
            
            # call the original function
            return func(*args, **kwargs)
        
        return wrapper
def package_init(config_path: str):
    """
    Initialize the package by scanning directories and registering functions.
    Args:
        config_path: Path to the configuration YAML file.
    """
    if os.path.exists(BRAIN_INIT_FILE):
        os.remove(BRAIN_INIT_FILE)
    if os.path.exists(SKILL_INIT_FILE):
        os.remove(SKILL_INIT_FILE)
    config_path = os.path.join(BASE_PATH, config_path)
    if not os.path.exists(config_path):
        print(f"[eaios] Error: The configuration file '{config_path}' does not exist.")
        return
    config = {}
    with open(config_path, 'r', encoding='utf-8') as f:
        config = yaml.safe_load(f)
    for base,entrys in config.items():
        if entrys is None:
            continue
        for entry in entrys:
            entry_dir = os.path.join(BASE_PATH, base, entry)
            print("[DEBUG] entry_dir:", entry_dir)
            if not os.path.exists(entry_dir):
                print(f"[eaios] Error: The '{entry_dir}' directory was not found at '{base}'")
                continue
            base_package = f"DeepEmbody.{base}.{entry}"
            eaios.scan_dir(base_package, entry_dir)
    print("before finalize")
    eaios.finalize()
    registry = FunctionRegistry()
    print(f"[eaios] Package initialized with {registry.gen_lens()} functions registered.")

import rclpy
from rclpy.node import Node
from std_srvs.srv import Trigger, SetBool

class NodeController(Node):
    def __init__(self):
        super().__init__('node_controller')


    def call_service(self, service_name, request):
        if service_name == "get_count":
            client = self.create_client(Trigger, service_name)
        elif service_name == "modify_name":
            client = self.create_client(Trigger, service_name)
        elif service_name == "shutdown_node":
            client = self.create_client(Trigger, service_name)
        
        # 调用服务
        if not client.wait_for_service(timeout_sec=10.0):
            self.get_logger().error(f'Service {service_name} not available')
            return None
        future = client.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        if future.result() is not None:
            self.get_logger().info(f'Service {service_name} called successfully')
            return future.result()
        else:
            self.get_logger().error(f'Service {service_name} call failed')
            return None
# from mcp import tool
print(id(eaios.mcp))
print("eaios.__module__ =", eaios.__module__)
print("eaios class id =", id(eaios))

async def mcp_start():
    """start mcp server in asyncio loop"""
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, eaios.mcp.run, "sse")

# Example usage
if __name__ == "__main__":
    import yaml, argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", type=str, default="config/include.yaml")
    args = parser.parse_args()
    package_init(args.config)
    with open("test.txt","w") as f:
        import time
        f.write(str(time.time()))
        registry = FunctionRegistry()
        print(f"[eaios] Finalized with {registry.gen_lens()} functions registered.")
        print(eaios.FUNCTION_REGISTRY)
        # mcp_start()
